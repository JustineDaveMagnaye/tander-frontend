/**
 * TANDER IncomingCallModal Component
 * Modal overlay for incoming call notifications
 *
 * QA Fixes Applied:
 * - BUG-106: Updated to accept consolidated IncomingCall type
 * - BUG-108: Can be used by WebSocketProvider
 * - BUG-110: Improved animation cleanup
 *
 * Follows design_system2.md:
 * - Large touch targets (64px+) for senior-friendly interaction
 * - High contrast for visibility
 * - Clear visual feedback with animations
 * - Accessible controls
 */

import React, { useEffect, useRef, useCallback } from 'react';
import {
  View,
  StyleSheet,
  TouchableOpacity,
  Image,
  Modal,
  Animated,
  Vibration,
  Platform,
} from 'react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { Feather } from '@expo/vector-icons';
import { Text } from '@shared/components';
import { colors } from '@shared/styles/colors';
import { spacing, shadows } from '@shared/styles/spacing';
import { useResponsive } from '@shared/hooks/useResponsive';

// BUG-106: Flexible caller type that works with multiple sources
interface CallerInfo {
  id: string;
  name?: string;  // Made optional for ChatUser compatibility
  firstName?: string;
  lastName?: string;
  profilePhoto?: string;
}

// BUG-106: Flexible incoming call type
export interface IncomingCallInfo {
  id: string;
  conversationId: string;
  caller: CallerInfo;
  type: 'voice' | 'video';
  timestamp: Date;
}

interface IncomingCallModalProps {
  visible?: boolean;
  call: IncomingCallInfo | null;
  onAccept: () => void;
  onDecline: () => void;
}

export const IncomingCallModal: React.FC<IncomingCallModalProps> = ({
  visible,
  call,
  onAccept,
  onDecline,
}) => {
  const insets = useSafeAreaInsets();
  const { isLandscape, isTablet, hp, wp, moderateScale } = useResponsive();

  // Animations
  const pulseAnim = useRef(new Animated.Value(1)).current;
  const slideAnim = useRef(new Animated.Value(-100)).current;
  const opacityAnim = useRef(new Animated.Value(0)).current;

  // Animation refs for cleanup - BUG-110
  const pulseAnimationRef = useRef<Animated.CompositeAnimation | null>(null);
  const entryAnimationRef = useRef<Animated.CompositeAnimation | null>(null);
  const vibrationIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const isMountedRef = useRef(true);

  // BUG-110: Cleanup helper
  const cleanupAnimations = useCallback(() => {
    if (pulseAnimationRef.current) {
      pulseAnimationRef.current.stop();
      pulseAnimationRef.current = null;
    }
    if (entryAnimationRef.current) {
      entryAnimationRef.current.stop();
      entryAnimationRef.current = null;
    }
    if (vibrationIntervalRef.current) {
      clearInterval(vibrationIntervalRef.current);
      vibrationIntervalRef.current = null;
    }
    Vibration.cancel();
    pulseAnim.setValue(1);
    slideAnim.setValue(-100);
    opacityAnim.setValue(0);
  }, [pulseAnim, slideAnim, opacityAnim]);

  // Component mount/unmount
  useEffect(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
      cleanupAnimations();
    };
  }, [cleanupAnimations]);

  // Handle call visibility - BUG-110: Improved cleanup
  useEffect(() => {
    const isVisible = visible !== undefined ? visible : !!call;

    if (isVisible && call) {
      // Start vibration pattern
      const pattern = Platform.OS === 'android'
        ? [0, 500, 500, 500, 500, 500]
        : [500, 500, 500, 500];

      vibrationIntervalRef.current = setInterval(() => {
        if (isMountedRef.current) {
          Vibration.vibrate(pattern);
        }
      }, 3000);

      // Initial vibration
      Vibration.vibrate(pattern);

      // Start entry animations
      entryAnimationRef.current = Animated.parallel([
        Animated.timing(slideAnim, {
          toValue: 0,
          duration: 300,
          useNativeDriver: true,
        }),
        Animated.timing(opacityAnim, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true,
        }),
      ]);
      entryAnimationRef.current.start();

      // Pulse animation
      pulseAnimationRef.current = Animated.loop(
        Animated.sequence([
          Animated.timing(pulseAnim, {
            toValue: 1.1,
            duration: 600,
            useNativeDriver: true,
          }),
          Animated.timing(pulseAnim, {
            toValue: 1,
            duration: 600,
            useNativeDriver: true,
          }),
        ])
      );
      pulseAnimationRef.current.start();
    } else {
      cleanupAnimations();
    }

    return () => {
      if (!isVisible) {
        cleanupAnimations();
      }
    };
  }, [visible, call, slideAnim, opacityAnim, pulseAnim, cleanupAnimations]);

  // Dismiss animation
  const handleDismiss = useCallback((callback: () => void) => {
    console.log('[IncomingCallModal] handleDismiss called');
    cleanupAnimations();
    // Call callback immediately, then animate
    callback();
    Animated.parallel([
      Animated.timing(slideAnim, {
        toValue: -100,
        duration: 200,
        useNativeDriver: true,
      }),
      Animated.timing(opacityAnim, {
        toValue: 0,
        duration: 200,
        useNativeDriver: true,
      }),
    ]).start();
  }, [slideAnim, opacityAnim, cleanupAnimations]);

  // Determine if modal should be visible
  const isModalVisible = visible !== undefined ? visible : !!call;

  if (!call) return null;

  // Get caller display name - BUG-106: Handle multiple name formats
  const getCallerDisplayName = (): string => {
    if (call.caller.firstName) {
      return call.caller.lastName
        ? `${call.caller.firstName} ${call.caller.lastName}`
        : call.caller.firstName;
    }
    return call.caller.name || 'Unknown';
  };

  const getCallerInitial = (): string => {
    if (call.caller.firstName) {
      return call.caller.firstName.charAt(0).toUpperCase();
    }
    return (call.caller.name || 'U').charAt(0).toUpperCase();
  };

  // Responsive sizes
  const avatarSize = isLandscape
    ? Math.min(hp(25), wp(15), 100)
    : isTablet
      ? moderateScale(120)
      : moderateScale(100);

  const buttonSize = isLandscape
    ? Math.min(hp(16), 68)
    : isTablet
      ? moderateScale(76)
      : moderateScale(68);

  const nameSize = isLandscape
    ? Math.min(hp(6), wp(4), 24)
    : isTablet
      ? moderateScale(28)
      : moderateScale(24);

  const subtitleSize = isLandscape
    ? Math.min(hp(4), wp(2.5), 16)
    : isTablet
      ? moderateScale(18)
      : moderateScale(16);

  const iconSize = isLandscape
    ? Math.min(hp(6), 28)
    : isTablet
      ? moderateScale(32)
      : moderateScale(28);

  return (
    <Modal
      visible={isModalVisible}
      transparent
      animationType="none"
      statusBarTranslucent
      onRequestClose={() => handleDismiss(onDecline)}
    >
      <Animated.View
        style={[
          styles.overlay,
          { opacity: opacityAnim },
        ]}
      >
        <Animated.View
          style={[
            styles.container,
            {
              paddingTop: insets.top + spacing.xl,
              paddingBottom: insets.bottom + spacing.xl,
              transform: [{ translateY: slideAnim }],
            },
            isLandscape && styles.containerLandscape,
          ]}
        >
          {/* Gradient background */}
          <LinearGradient
            colors={['rgba(0,0,0,0.95)', 'rgba(22,33,62,0.95)']}
            style={StyleSheet.absoluteFill}
          />

          {/* Content */}
          <View style={[styles.content, isLandscape && styles.contentLandscape]}>
            {/* Avatar with pulse animation */}
            <Animated.View style={{ transform: [{ scale: pulseAnim }] }}>
              {/* Ring animation circles */}
              <View style={styles.ringContainer}>
                <Animated.View
                  style={[
                    styles.ring,
                    {
                      width: avatarSize * 1.6,
                      height: avatarSize * 1.6,
                      borderRadius: avatarSize * 0.8,
                      opacity: pulseAnim.interpolate({
                        inputRange: [1, 1.1],
                        outputRange: [0.3, 0],
                      }),
                    },
                  ]}
                />
                <Animated.View
                  style={[
                    styles.ring,
                    {
                      width: avatarSize * 1.3,
                      height: avatarSize * 1.3,
                      borderRadius: avatarSize * 0.65,
                      opacity: pulseAnim.interpolate({
                        inputRange: [1, 1.1],
                        outputRange: [0.5, 0.2],
                      }),
                    },
                  ]}
                />

                {/* Avatar */}
                {call.caller.profilePhoto ? (
                  <Image
                    source={{ uri: call.caller.profilePhoto }}
                    style={[
                      styles.avatar,
                      {
                        width: avatarSize,
                        height: avatarSize,
                        borderRadius: avatarSize / 2,
                      },
                    ]}
                  />
                ) : (
                  <View
                    style={[
                      styles.avatarPlaceholder,
                      {
                        width: avatarSize,
                        height: avatarSize,
                        borderRadius: avatarSize / 2,
                      },
                    ]}
                  >
                    <Text style={[styles.avatarText, { fontSize: avatarSize * 0.4 }]}>
                      {getCallerInitial()}
                    </Text>
                  </View>
                )}
              </View>
            </Animated.View>

            {/* Caller info */}
            <View style={styles.callerInfo}>
              <Text style={[styles.callerName, { fontSize: nameSize }]}>
                {getCallerDisplayName()}
              </Text>
              <View style={styles.callTypeContainer}>
                <Feather
                  name={call.type === 'video' ? 'video' : 'phone'}
                  size={subtitleSize}
                  color={colors.white}
                  style={styles.callTypeIcon}
                />
                <Text style={[styles.callType, { fontSize: subtitleSize }]}>
                  {call.type === 'video' ? 'Incoming Video Call' : 'Incoming Voice Call'}
                </Text>
              </View>
            </View>

            {/* Action buttons */}
            <View style={[styles.actions, isLandscape && styles.actionsLandscape]}>
              {/* Decline */}
              <View style={styles.actionContainer}>
                <TouchableOpacity
                  onPress={() => handleDismiss(onDecline)}
                  style={[
                    styles.declineButton,
                    {
                      width: buttonSize,
                      height: buttonSize,
                      borderRadius: buttonSize / 2,
                    },
                  ]}
                  accessible={true}
                  accessibilityLabel="Decline call"
                  accessibilityRole="button"
                  accessibilityHint={`Decline ${call.type} call from ${getCallerDisplayName()}`}
                >
                  <Feather name="x" size={iconSize} color={colors.white} />
                </TouchableOpacity>
                <Text style={styles.actionLabel}>Decline</Text>
              </View>

              {/* Accept */}
              <View style={styles.actionContainer}>
                <TouchableOpacity
                  onPress={() => handleDismiss(onAccept)}
                  accessible={true}
                  accessibilityLabel="Accept call"
                  accessibilityRole="button"
                  accessibilityHint={`Accept ${call.type} call from ${getCallerDisplayName()}`}
                >
                  <LinearGradient
                    colors={[colors.semantic.success, '#2E7D32']}
                    style={[
                      styles.acceptButton,
                      {
                        width: buttonSize,
                        height: buttonSize,
                        borderRadius: buttonSize / 2,
                      },
                    ]}
                  >
                    <Feather
                      name={call.type === 'video' ? 'video' : 'phone'}
                      size={iconSize}
                      color={colors.white}
                    />
                  </LinearGradient>
                </TouchableOpacity>
                <Text style={styles.actionLabel}>Accept</Text>
              </View>
            </View>
          </View>
        </Animated.View>
      </Animated.View>
    </Modal>
  );
};

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
  },
  container: {
    flex: 1,
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: spacing.xl,
  },
  containerLandscape: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    paddingHorizontal: spacing.xxl,
  },
  content: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    width: '100%',
  },
  contentLandscape: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    alignItems: 'center',
  },
  ringContainer: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  ring: {
    position: 'absolute',
    borderWidth: 2,
    borderColor: colors.teal.primary,
  },
  avatar: {
    backgroundColor: colors.neutral.border,
    borderWidth: 4,
    borderColor: colors.white,
    ...shadows.large,
  },
  avatarPlaceholder: {
    backgroundColor: colors.teal.primary,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 4,
    borderColor: colors.white,
    ...shadows.large,
  },
  avatarText: {
    color: colors.white,
    fontWeight: '700',
  },
  callerInfo: {
    alignItems: 'center',
    marginTop: spacing.xl,
    marginBottom: spacing.xxl,
  },
  callerName: {
    color: colors.white,
    fontWeight: '700',
    textAlign: 'center',
    textShadowColor: 'rgba(0,0,0,0.5)',
    textShadowOffset: { width: 0, height: 2 },
    textShadowRadius: 4,
  },
  callTypeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginTop: spacing.xs,
  },
  callTypeIcon: {
    marginRight: spacing.xs,
  },
  callType: {
    color: 'rgba(255,255,255,0.8)',
    textAlign: 'center',
  },
  actions: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    width: '100%',
    maxWidth: 300,
  },
  actionsLandscape: {
    maxWidth: 200,
    flexDirection: 'column',
    gap: spacing.xl,
  },
  actionContainer: {
    alignItems: 'center',
  },
  declineButton: {
    backgroundColor: colors.semantic.error,
    justifyContent: 'center',
    alignItems: 'center',
    ...shadows.large,
  },
  acceptButton: {
    justifyContent: 'center',
    alignItems: 'center',
    ...shadows.large,
  },
  buttonIcon: {
    color: colors.white,
    fontWeight: '600',
  },
  actionLabel: {
    color: 'rgba(255,255,255,0.8)',
    fontSize: 14,
    marginTop: spacing.xs,
    fontWeight: '500',
  },
});

export default IncomingCallModal;
