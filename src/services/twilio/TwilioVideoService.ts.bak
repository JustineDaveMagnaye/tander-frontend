/**
 * Twilio Video Service for React Native
 *
 * Uses react-native-webrtc for WebRTC peer connections with:
 * - Full peer-to-peer audio/video calling
 * - Proper ICE candidate exchange
 * - SDP offer/answer negotiation via WebSocket signaling
 *
 * This implementation provides:
 * - Full React Native compatibility
 * - Native WebRTC performance
 * - Real audio/video streaming between devices
 */

import {
  RTCPeerConnection,
  RTCSessionDescription,
  RTCIceCandidate,
  mediaDevices,
  MediaStream,
  MediaStreamTrack,
} from 'react-native-webrtc';
import { twilioApi, CallType } from '../api/twilioApi';
import { stompService, WebRTCSignal } from '../websocket/StompService';

/**
 * Check if call type is video (handles both uppercase and lowercase)
 */
const isVideoCall = (callType: CallType): boolean => {
  return callType.toLowerCase() === 'video';
};

// Try to import InCallManager for audio routing
let InCallManager: {
  start: (options?: { media?: string; auto?: boolean; ringback?: string }) => void;
  stop: (options?: { busytone?: string }) => void;
  setSpeakerphoneOn: (on: boolean) => void;
  setKeepScreenOn: (on: boolean) => void;
  turnScreenOn: () => void;
  turnScreenOff: () => void;
} | null = null;

try {
  InCallManager = require('react-native-incall-manager').default;
} catch (e) {
  console.warn('[TwilioVideo] InCallManager not available');
}

// ICE Servers configuration for WebRTC
const ICE_SERVERS = {
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' },
    { urls: 'stun:stun2.l.google.com:19302' },
    { urls: 'stun:stun3.l.google.com:19302' },
    { urls: 'stun:stun4.l.google.com:19302' },
  ],
};

// ==================== Types ====================

export type TwilioCallState =
  | 'idle'
  | 'initiating'
  | 'ringing'
  | 'connecting'
  | 'connected'
  | 'reconnecting'
  | 'ended'
  | 'failed';

export interface TwilioCallInfo {
  roomName: string;
  roomSid: string;
  callSessionId: number;
  callType: CallType;
  callerId: number;
  receiverId: number;
  receiverName: string;
  isOutgoing: boolean;
}

export interface TwilioParticipant {
  identity: string;
  sid: string;
  audioEnabled: boolean;
  videoEnabled: boolean;
}

type StateChangeCallback = (state: TwilioCallState) => void;
type ErrorCallback = (error: string) => void;
type StreamCallback = (stream: MediaStream | null, type: 'local' | 'remote') => void;

// ==================== Service ====================

class TwilioVideoService {
  private currentCall: TwilioCallInfo | null = null;
  private callState: TwilioCallState = 'idle';

  // WebRTC
  private peerConnection: RTCPeerConnection | null = null;
  private pendingIceCandidates: RTCIceCandidateInit[] = [];
  private hasRemoteDescription: boolean = false;

  // Queue for signals that arrive before peer connection is ready
  private pendingOffer: WebRTCSignal | null = null;
  private pendingSignals: WebRTCSignal[] = [];

  // Deduplication - prevent processing same signal twice (from queue and topic)
  private processedSignalIds: Set<string> = new Set();

  // Streams
  private localStream: MediaStream | null = null;
  private remoteStream: MediaStream | null = null;

  // Audio/Video state
  private isAudioEnabled: boolean = true;
  private isVideoEnabled: boolean = true;
  private isSpeakerOn: boolean = false;
  private isFrontCamera: boolean = true;

  // Callbacks
  private stateChangeCallbacks: Set<StateChangeCallback> = new Set();
  private errorCallbacks: Set<ErrorCallback> = new Set();
  private streamCallbacks: Set<StreamCallback> = new Set();

  // Timeouts
  private ringingTimeout: NodeJS.Timeout | null = null;
  private readonly RINGING_TIMEOUT_MS = 45000; // 45 seconds

  // Duration tracking
  private callStartTime: number | null = null;
  private durationInterval: NodeJS.Timeout | null = null;
  private duration: number = 0;

  // WebRTC signaling unsubscribe
  private webrtcUnsubscribe: (() => void) | null = null;

  constructor() {
    console.log('[TwilioVideo] Service initialized');
    this.setupWebRTCSignaling();
  }

  // ==================== WebRTC Signaling ====================

  /**
   * Set up WebRTC signaling via STOMP WebSocket
   */
  private setupWebRTCSignaling(): void {
    this.webrtcUnsubscribe = stompService.onWebRTCSignal((signal: WebRTCSignal) => {
      console.log('[TwilioVideo] 游니 WebRTC signal received:', signal.type);
      this.handleWebRTCSignal(signal);
    });
    console.log('[TwilioVideo] WebRTC signaling set up');
  }

  /**
   * Handle incoming WebRTC signaling message
   */
  private async handleWebRTCSignal(signal: WebRTCSignal): Promise<void> {
    // Generate a unique ID for this signal to prevent duplicate processing
    // (signals arrive via both queue and topic subscriptions)
    const signalId = `${signal.type}_${signal.roomName}_${signal.fromUserId}_${signal.timestamp}`;

    // Check for duplicate
    if (this.processedSignalIds.has(signalId)) {
      console.log('[TwilioVideo] 游니 Ignoring duplicate signal:', signal.type);
      return;
    }

    // Mark as processed (keep only last 100 to prevent memory leak)
    this.processedSignalIds.add(signalId);
    if (this.processedSignalIds.size > 100) {
      const firstKey = this.processedSignalIds.values().next().value;
      if (firstKey) this.processedSignalIds.delete(firstKey);
    }

    try {
      switch (signal.type) {
        case 'offer':
          // If no peer connection yet (receiver hasn't accepted), queue the offer
          if (!this.peerConnection) {
            console.log('[TwilioVideo] 游니 Queueing offer - peer connection not ready yet');
            this.pendingOffer = signal;
            return;
          }
          await this.handleRemoteOffer(signal);
          break;
        case 'answer':
          await this.handleRemoteAnswer(signal);
          break;
        case 'ice-candidate':
          // If no peer connection yet, queue the ICE candidate
          if (!this.peerConnection) {
            console.log('[TwilioVideo] 游니 Queueing ICE candidate - peer connection not ready yet');
            this.pendingSignals.push(signal);
            return;
          }
          await this.handleRemoteIceCandidate(signal);
          break;
        case 'hangup':
          this.handleRemoteHangup(signal);
          break;
        case 'error':
          console.error('[TwilioVideo] WebRTC signaling error:', signal.error);
          this.notifyError(signal.error || 'Signaling error');
          break;
      }
    } catch (error: any) {
      console.error('[TwilioVideo] Error handling WebRTC signal:', error);
    }
  }

  /**
   * Handle remote SDP offer (we are the receiver)
   */
  private async handleRemoteOffer(signal: WebRTCSignal): Promise<void> {
    console.log('[TwilioVideo] 游니 Handling remote offer from', signal.fromUserId);

    if (!this.peerConnection || !signal.sdp) {
      console.warn('[TwilioVideo] No peer connection or SDP for offer');
      return;
    }

    try {
      // Update currentCall with the correct callerId from the signal
      // This is important because acceptIncomingCall may not have had the callerId
      if (this.currentCall && signal.fromUserId) {
        this.currentCall.callerId = signal.fromUserId;
        console.log('[TwilioVideo] Updated callerId from offer signal:', signal.fromUserId);
      }

      // Set remote description
      const remoteDesc = new RTCSessionDescription(signal.sdp);
      await this.peerConnection.setRemoteDescription(remoteDesc);
      this.hasRemoteDescription = true;
      console.log('[TwilioVideo] Remote description set (offer)');

      // Process any pending ICE candidates
      await this.processPendingIceCandidates();

      // Create and send answer
      const answer = await this.peerConnection.createAnswer();
      await this.peerConnection.setLocalDescription(answer);
      console.log('[TwilioVideo] Local description set (answer)');

      // Send answer to remote peer
      if (this.currentCall) {
        stompService.sendWebRTCAnswer(
          this.currentCall.roomName,
          signal.fromUserId,
          answer
        );
        console.log('[TwilioVideo] 游니 Sent WebRTC answer to', signal.fromUserId);
      }
    } catch (error) {
      console.error('[TwilioVideo] Error handling remote offer:', error);
    }
  }

  /**
   * Handle remote SDP answer (we are the caller)
   */
  private async handleRemoteAnswer(signal: WebRTCSignal): Promise<void> {
    console.log('[TwilioVideo] 游니 Handling remote answer from', signal.fromUserId);

    if (!this.peerConnection || !signal.sdp) {
      console.warn('[TwilioVideo] No peer connection or SDP for answer');
      return;
    }

    try {
      const remoteDesc = new RTCSessionDescription(signal.sdp);
      await this.peerConnection.setRemoteDescription(remoteDesc);
      this.hasRemoteDescription = true;
      console.log('[TwilioVideo] Remote description set (answer)');

      // Process any pending ICE candidates
      await this.processPendingIceCandidates();
    } catch (error) {
      console.error('[TwilioVideo] Error handling remote answer:', error);
    }
  }

  /**
   * Handle remote ICE candidate
   */
  private async handleRemoteIceCandidate(signal: WebRTCSignal): Promise<void> {
    if (!signal.candidate) {
      return;
    }

    if (!this.peerConnection) {
      console.warn('[TwilioVideo] No peer connection for ICE candidate');
      return;
    }

    // If we don't have remote description yet, queue the candidate
    if (!this.hasRemoteDescription) {
      console.log('[TwilioVideo] Queuing ICE candidate (no remote description yet)');
      this.pendingIceCandidates.push(signal.candidate);
      return;
    }

    try {
      const candidate = new RTCIceCandidate(signal.candidate);
      await this.peerConnection.addIceCandidate(candidate);
      console.log('[TwilioVideo] Added remote ICE candidate');
    } catch (error) {
      console.error('[TwilioVideo] Error adding ICE candidate:', error);
    }
  }

  /**
   * Process queued ICE candidates after remote description is set
   */
  private async processPendingIceCandidates(): Promise<void> {
    if (this.pendingIceCandidates.length === 0 || !this.peerConnection) {
      return;
    }

    console.log(`[TwilioVideo] Processing ${this.pendingIceCandidates.length} pending ICE candidates`);

    for (const candidateInit of this.pendingIceCandidates) {
      try {
        const candidate = new RTCIceCandidate(candidateInit);
        await this.peerConnection.addIceCandidate(candidate);
      } catch (error) {
        console.error('[TwilioVideo] Error adding pending ICE candidate:', error);
      }
    }

    this.pendingIceCandidates = [];
  }

  /**
   * Process queued WebRTC signals after peer connection is created (for receiver)
   * This handles the timing issue where offer/ICE candidates arrive before Accept is pressed
   */
  private async processPendingSignals(): Promise<void> {
    // Process pending offer first
    if (this.pendingOffer) {
      console.log('[TwilioVideo] 游니 Processing queued offer');
      await this.handleRemoteOffer(this.pendingOffer);
      this.pendingOffer = null;
    }

    // Process any pending ICE candidate signals
    if (this.pendingSignals.length > 0) {
      console.log(`[TwilioVideo] 游니 Processing ${this.pendingSignals.length} queued ICE candidates`);
      for (const signal of this.pendingSignals) {
        if (signal.type === 'ice-candidate') {
          await this.handleRemoteIceCandidate(signal);
        }
      }
      this.pendingSignals = [];
    }
  }

  /**
   * Handle remote hangup
   */
  private handleRemoteHangup(signal: WebRTCSignal): void {
    console.log('[TwilioVideo] Remote party hung up:', signal.reason);

    if (this.currentCall?.roomName === signal.roomName) {
      this.notifyError('Call ended by remote party');
      this.setCallState('ended');
      this.cleanup();
    }
  }

  // ==================== Peer Connection ====================

  /**
   * Create and configure RTCPeerConnection
   */
  private async createPeerConnection(targetUserId: number): Promise<void> {
    console.log('[TwilioVideo] Creating peer connection');

    // Close existing connection if any
    if (this.peerConnection) {
      this.peerConnection.close();
    }

    this.peerConnection = new RTCPeerConnection(ICE_SERVERS);
    this.hasRemoteDescription = false;
    this.pendingIceCandidates = [];

    // Add local tracks to connection
    if (this.localStream) {
      this.localStream.getTracks().forEach((track: MediaStreamTrack) => {
        console.log('[TwilioVideo] Adding local track to peer connection:', track.kind);
        this.peerConnection?.addTrack(track, this.localStream!);
      });
    }

    // Handle ICE candidates
    // Note: We use this.currentCall instead of captured targetUserId
    // because callerId might be updated later (e.g., from pending offer)
    this.peerConnection.onicecandidate = (event) => {
      if (event.candidate && this.currentCall) {
        // Dynamically get the target user ID - for outgoing calls it's receiverId,
        // for incoming calls it's callerId
        const target = this.currentCall.isOutgoing
          ? this.currentCall.receiverId
          : this.currentCall.callerId;

        if (target) {
          console.log('[TwilioVideo] 游니 Sending ICE candidate to user', target);
          stompService.sendWebRTCIceCandidate(
            this.currentCall.roomName,
            target,
            event.candidate.toJSON()
          );
        } else {
          console.warn('[TwilioVideo] Cannot send ICE candidate - no target user ID');
        }
      }
    };

    // Handle ICE connection state changes
    this.peerConnection.oniceconnectionstatechange = () => {
      const state = this.peerConnection?.iceConnectionState;
      console.log('[TwilioVideo] ICE connection state:', state);

      switch (state) {
        case 'connected':
        case 'completed':
          if (this.callState === 'connecting') {
            this.setCallState('connected');
            this.startDurationTimer();
          }
          break;
        case 'disconnected':
          this.setCallState('reconnecting');
          break;
        case 'failed':
          this.notifyError('Connection failed');
          this.setCallState('failed');
          this.cleanup();
          break;
        case 'closed':
          // Connection was closed, likely intentionally
          break;
      }
    };

    // Handle remote tracks
    this.peerConnection.ontrack = (event) => {
      console.log('[TwilioVideo] 游꿘 Remote track received:', event.track.kind);

      if (event.streams && event.streams[0]) {
        this.remoteStream = event.streams[0];
        console.log('[TwilioVideo] 游꿘 Remote stream set');
        this.notifyStream(this.remoteStream, 'remote');
      }
    };

    console.log('[TwilioVideo] Peer connection created');
  }

  // ==================== Public API ====================

  /**
   * Initiate an outgoing call
   */
  async initiateCall(
    receiverId: number,
    receiverName: string,
    callType: CallType
  ): Promise<TwilioCallInfo> {
    console.log(`[TwilioVideo] Initiating ${callType} call to user ${receiverId}`);

    if (this.callState !== 'idle') {
      throw new Error('Already in a call');
    }

    this.setCallState('initiating');

    try {
      // Create room via backend (this also notifies the receiver)
      const roomResponse = await twilioApi.createRoom(receiverId, callType);
      console.log('[TwilioVideo] Room created:', roomResponse.roomName);

      // Store call info
      this.currentCall = {
        roomName: roomResponse.roomName,
        roomSid: roomResponse.roomSid,
        callSessionId: roomResponse.callSessionId,
        callType: callType,
        callerId: 0, // Set by backend
        receiverId: receiverId,
        receiverName: receiverName,
        isOutgoing: true,
      };

      // Start audio session
      this.startAudioSession(isVideoCall(callType));

      // Get local media stream
      await this.acquireLocalStream(isVideoCall(callType));

      // Create peer connection
      await this.createPeerConnection(receiverId);

      // Create and send offer
      if (this.peerConnection) {
        const offer = await this.peerConnection.createOffer({
          offerToReceiveAudio: true,
          offerToReceiveVideo: isVideoCall(callType),
        });
        await this.peerConnection.setLocalDescription(offer);
        console.log('[TwilioVideo] Local description set (offer)');

        // Send offer to receiver
        stompService.sendWebRTCOffer(
          roomResponse.roomName,
          receiverId,
          offer
        );
        console.log('[TwilioVideo] 游니 Sent WebRTC offer to user', receiverId);
      }

      this.setCallState('ringing');
      this.startRingingTimeout();

      return this.currentCall;
    } catch (error: any) {
      console.error('[TwilioVideo] Failed to initiate call:', error);
      this.setCallState('failed');
      this.notifyError(error.message || 'Failed to initiate call');
      this.cleanup();
      throw error;
    }
  }

  /**
   * Accept an incoming call
   */
  async acceptIncomingCall(roomName: string, callType: CallType): Promise<void> {
    console.log(`[TwilioVideo] Accepting call in room ${roomName}`);

    if (this.callState !== 'idle' && this.callState !== 'ringing') {
      throw new Error('Cannot accept call in current state');
    }

    this.setCallState('connecting');

    try {
      // Accept call via backend (this notifies the caller)
      await twilioApi.acceptCall(roomName);
      console.log('[TwilioVideo] Call accepted on backend');

      // Get callerId from pending offer if available (it arrives before Accept is pressed)
      // This is critical for knowing who to send ICE candidates to
      let callerId = 0;
      if (this.pendingOffer && this.pendingOffer.fromUserId) {
        callerId = this.pendingOffer.fromUserId;
        console.log('[TwilioVideo] Got callerId from pending offer:', callerId);
      }

      // Store call info if not already set
      if (!this.currentCall) {
        this.currentCall = {
          roomName: roomName,
          roomSid: '',
          callSessionId: 0,
          callType: callType,
          callerId: callerId,
          receiverId: 0,
          receiverName: '',
          isOutgoing: false,
        };
      } else if (callerId) {
        // Update callerId if we got it from the pending offer
        this.currentCall.callerId = callerId;
      }

      // Start audio session
      this.startAudioSession(isVideoCall(callType));

      // Get local media stream
      await this.acquireLocalStream(isVideoCall(callType));

      // Create peer connection with the caller's ID so ICE candidates go to the right place
      await this.createPeerConnection(this.currentCall.callerId);

      // Process any queued signals (offer and ICE candidates that arrived before Accept)
      // This is critical: the caller sends offer immediately, but receiver's peer connection
      // only gets created when they press Accept - so we need to process queued signals
      console.log('[TwilioVideo] Processing any queued WebRTC signals...');
      await this.processPendingSignals();

      // State will transition to 'connected' when ICE connection completes
      console.log('[TwilioVideo] Waiting for WebRTC connection...');
    } catch (error: any) {
      console.error('[TwilioVideo] Failed to accept call:', error);
      this.setCallState('failed');
      this.notifyError(error.message || 'Failed to accept call');
      this.cleanup();
      throw error;
    }
  }

  /**
   * Decline an incoming call
   */
  async declineIncomingCall(roomName: string): Promise<void> {
    console.log(`[TwilioVideo] Declining call in room ${roomName}`);

    try {
      await twilioApi.declineCall(roomName);
      this.setCallState('ended');
      this.cleanup();
    } catch (error: any) {
      console.error('[TwilioVideo] Failed to decline call:', error);
      this.notifyError(error.message || 'Failed to decline call');
    }
  }

  /**
   * End the current call
   */
  async endCall(reason: string = 'hangup'): Promise<void> {
    console.log(`[TwilioVideo] Ending call, reason: ${reason}`);

    if (!this.currentCall) {
      console.warn('[TwilioVideo] No active call to end');
      return;
    }

    // Send hangup signal to remote peer
    const targetUserId = this.currentCall.isOutgoing
      ? this.currentCall.receiverId
      : this.currentCall.callerId;

    if (targetUserId) {
      stompService.sendWebRTCHangup(
        this.currentCall.roomName,
        targetUserId,
        reason
      );
    }

    try {
      await twilioApi.endCall(this.currentCall.roomName, reason);
    } catch (error) {
      console.error('[TwilioVideo] Error ending call on backend:', error);
    }

    this.setCallState('ended');
    this.cleanup();
  }

  /**
   * Handle incoming call notification
   */
  handleIncomingCall(
    roomName: string,
    callerId: number,
    callerName: string,
    callType: CallType
  ): void {
    console.log(`[TwilioVideo] Incoming ${callType} call from ${callerName}`);

    if (this.callState !== 'idle') {
      console.warn('[TwilioVideo] Already in a call, rejecting incoming');
      this.declineIncomingCall(roomName);
      return;
    }

    this.currentCall = {
      roomName: roomName,
      roomSid: '',
      callSessionId: 0,
      callType: callType,
      callerId: callerId,
      receiverId: 0,
      receiverName: callerName,
      isOutgoing: false,
    };

    this.setCallState('ringing');
  }

  /**
   * Handle when the remote party answers the call (for caller)
   * Called when WebSocket receives call_answered event
   */
  handleCallAnswered(roomName: string): void {
    console.log(`[TwilioVideo] Call answered in room ${roomName}`);

    // Only handle if we're the caller in ringing state
    if (this.callState !== 'ringing' || !this.currentCall?.isOutgoing) {
      console.log('[TwilioVideo] Ignoring call_answered - not caller or not ringing');
      return;
    }

    // Verify it's for our current call
    if (this.currentCall.roomName !== roomName) {
      console.log('[TwilioVideo] Ignoring call_answered - different room');
      return;
    }

    this.clearRingingTimeout();
    this.setCallState('connecting');
    // State will transition to 'connected' when ICE connection completes
  }

  /**
   * Handle when the remote party rejects the call (for caller)
   * Called when WebSocket receives call_declined event
   */
  handleCallRejected(roomName: string, reason: string = 'declined'): void {
    console.log(`[TwilioVideo] Call rejected in room ${roomName}, reason: ${reason}`);

    // Only handle if we're the caller in ringing state
    if (this.callState !== 'ringing' || !this.currentCall?.isOutgoing) {
      console.log('[TwilioVideo] Ignoring call_rejected - not caller or not ringing');
      return;
    }

    // Verify it's for our current call
    if (this.currentCall.roomName !== roomName) {
      console.log('[TwilioVideo] Ignoring call_rejected - different room');
      return;
    }

    this.clearRingingTimeout();
    this.notifyError(`Call ${reason}`);
    this.setCallState('ended');
    this.cleanup();
  }

  /**
   * Toggle audio (mute/unmute)
   */
  toggleAudio(): boolean {
    this.isAudioEnabled = !this.isAudioEnabled;
    console.log('[TwilioVideo] Audio toggled:', this.isAudioEnabled);

    if (this.localStream) {
      this.localStream.getAudioTracks().forEach((track: MediaStreamTrack) => {
        track.enabled = this.isAudioEnabled;
      });
    }

    return this.isAudioEnabled;
  }

  /**
   * Toggle video (show/hide)
   */
  toggleVideo(): boolean {
    this.isVideoEnabled = !this.isVideoEnabled;
    console.log('[TwilioVideo] Video toggled:', this.isVideoEnabled);

    if (this.localStream) {
      this.localStream.getVideoTracks().forEach((track: MediaStreamTrack) => {
        track.enabled = this.isVideoEnabled;
      });
    }

    return this.isVideoEnabled;
  }

  /**
   * Toggle speaker
   */
  toggleSpeaker(): boolean {
    this.isSpeakerOn = !this.isSpeakerOn;
    console.log('[TwilioVideo] Speaker toggled:', this.isSpeakerOn);

    if (InCallManager) {
      try {
        InCallManager.setSpeakerphoneOn(this.isSpeakerOn);
      } catch (error) {
        console.warn('[TwilioVideo] Failed to toggle speaker:', error);
      }
    }

    return this.isSpeakerOn;
  }

  /**
   * Switch camera (front/back)
   */
  async switchCamera(): Promise<void> {
    console.log('[TwilioVideo] Switching camera');

    if (!this.localStream) {
      console.warn('[TwilioVideo] No local stream to switch camera');
      return;
    }

    try {
      this.isFrontCamera = !this.isFrontCamera;

      // Stop current video tracks
      this.localStream.getVideoTracks().forEach((track: MediaStreamTrack) => {
        track.stop();
      });

      // Get new stream with switched camera
      const newStream = await mediaDevices.getUserMedia({
        audio: false,
        video: {
          facingMode: this.isFrontCamera ? 'user' : 'environment',
          width: { ideal: 1280 },
          height: { ideal: 720 },
        },
      });

      // Replace video track in local stream and peer connection
      const newVideoTrack = newStream.getVideoTracks()[0];
      if (newVideoTrack) {
        // Remove old video tracks from local stream
        this.localStream.getVideoTracks().forEach((track: MediaStreamTrack) => {
          this.localStream?.removeTrack(track);
        });

        // Add new video track to local stream
        this.localStream.addTrack(newVideoTrack);

        // Replace track in peer connection
        if (this.peerConnection) {
          const senders = this.peerConnection.getSenders();
          const videoSender = senders.find(s => s.track?.kind === 'video');
          if (videoSender) {
            await videoSender.replaceTrack(newVideoTrack);
          }
        }

        // Notify stream change
        this.notifyStream(this.localStream, 'local');
      }
    } catch (error) {
      console.error('[TwilioVideo] Failed to switch camera:', error);
      this.notifyError('Failed to switch camera');
      // Revert camera state
      this.isFrontCamera = !this.isFrontCamera;
    }
  }

  // ==================== Callbacks ====================

  onStateChange(callback: StateChangeCallback): () => void {
    this.stateChangeCallbacks.add(callback);
    return () => this.stateChangeCallbacks.delete(callback);
  }

  onError(callback: ErrorCallback): () => void {
    this.errorCallbacks.add(callback);
    return () => this.errorCallbacks.delete(callback);
  }

  onStream(callback: StreamCallback): () => void {
    this.streamCallbacks.add(callback);
    return () => this.streamCallbacks.delete(callback);
  }

  // ==================== Getters ====================

  getCallState(): TwilioCallState {
    return this.callState;
  }

  getCurrentCall(): TwilioCallInfo | null {
    return this.currentCall;
  }

  getLocalStream(): MediaStream | null {
    return this.localStream;
  }

  getRemoteStream(): MediaStream | null {
    return this.remoteStream;
  }

  getDuration(): number {
    return this.duration;
  }

  isAudioMuted(): boolean {
    return !this.isAudioEnabled;
  }

  isVideoMuted(): boolean {
    return !this.isVideoEnabled;
  }

  isSpeakerEnabled(): boolean {
    return this.isSpeakerOn;
  }

  isFrontCameraActive(): boolean {
    return this.isFrontCamera;
  }

  // ==================== Private Methods ====================

  private async acquireLocalStream(includeVideo: boolean): Promise<void> {
    console.log(`[TwilioVideo] Getting local stream, video: ${includeVideo}`);

    try {
      // Build constraints - for audio-only calls, completely exclude video key
      // to prevent camera permission requests on some Android devices
      const constraints: MediaStreamConstraints = {
        audio: {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
        } as MediaTrackConstraints,
      };

      // Only add video constraints for video calls
      if (includeVideo) {
        constraints.video = {
          facingMode: this.isFrontCamera ? 'user' : 'environment',
          width: { ideal: 1280 },
          height: { ideal: 720 },
          frameRate: { ideal: 30 },
        } as MediaTrackConstraints;
      }

      this.localStream = await mediaDevices.getUserMedia(constraints);
      console.log(`[TwilioVideo] Local stream obtained (video: ${includeVideo})`);

      // Notify stream
      this.notifyStream(this.localStream, 'local');
    } catch (error: any) {
      console.error('[TwilioVideo] Failed to get local stream:', error);
      throw new Error('Failed to access camera/microphone');
    }
  }

  private startAudioSession(isVideo: boolean): void {
    if (!InCallManager) return;

    try {
      InCallManager.start({ media: isVideo ? 'video' : 'audio' });
      InCallManager.setSpeakerphoneOn(isVideo); // Speaker on for video calls by default
      InCallManager.setKeepScreenOn(true);
      this.isSpeakerOn = isVideo;
    } catch (error) {
      console.warn('[TwilioVideo] Failed to start audio session:', error);
    }
  }

  private stopAudioSession(): void {
    if (!InCallManager) return;

    try {
      InCallManager.stop();
    } catch (error) {
      console.warn('[TwilioVideo] Failed to stop audio session:', error);
    }
  }

  private startRingingTimeout(): void {
    this.clearRingingTimeout();
    this.ringingTimeout = setTimeout(() => {
      console.log('[TwilioVideo] Ringing timeout');
      if (this.callState === 'ringing') {
        this.endCall('timeout');
      }
    }, this.RINGING_TIMEOUT_MS);
  }

  private clearRingingTimeout(): void {
    if (this.ringingTimeout) {
      clearTimeout(this.ringingTimeout);
      this.ringingTimeout = null;
    }
  }

  private startDurationTimer(): void {
    this.callStartTime = Date.now();
    this.duration = 0;

    this.durationInterval = setInterval(() => {
      if (this.callStartTime) {
        this.duration = Math.floor((Date.now() - this.callStartTime) / 1000);
      }
    }, 1000);
  }

  private stopDurationTimer(): void {
    if (this.durationInterval) {
      clearInterval(this.durationInterval);
      this.durationInterval = null;
    }
  }

  private cleanup(): void {
    console.log('[TwilioVideo] Cleaning up');

    this.clearRingingTimeout();
    this.stopDurationTimer();
    this.stopAudioSession();

    // Close peer connection
    if (this.peerConnection) {
      this.peerConnection.close();
      this.peerConnection = null;
    }

    // Stop local stream tracks
    if (this.localStream) {
      this.localStream.getTracks().forEach((track: MediaStreamTrack) => {
        track.stop();
      });
      this.localStream = null;
    }

    // Clear remote stream
    this.remoteStream = null;

    // Reset WebRTC state
    this.hasRemoteDescription = false;
    this.pendingIceCandidates = [];
    this.pendingOffer = null;
    this.pendingSignals = [];
    this.processedSignalIds.clear();

    // Reset state
    this.currentCall = null;
    this.isAudioEnabled = true;
    this.isVideoEnabled = true;
    this.isSpeakerOn = false;
    this.isFrontCamera = true;
    this.duration = 0;
    this.callStartTime = null;

    // Notify null streams
    this.notifyStream(null, 'local');
    this.notifyStream(null, 'remote');

    // Reset to idle after a brief delay
    setTimeout(() => {
      if (this.callState === 'ended' || this.callState === 'failed') {
        this.setCallState('idle');
      }
    }, 2000);
  }

  private setCallState(state: TwilioCallState): void {
    console.log(`[TwilioVideo] State change: ${this.callState} -> ${state}`);
    this.callState = state;
    this.stateChangeCallbacks.forEach((cb) => cb(state));
  }

  private notifyError(error: string): void {
    this.errorCallbacks.forEach((cb) => cb(error));
  }

  private notifyStream(stream: MediaStream | null, type: 'local' | 'remote'): void {
    this.streamCallbacks.forEach((cb) => cb(stream, type));
  }
}

// Export singleton instance
export const twilioVideoService = new TwilioVideoService();
export default twilioVideoService;
